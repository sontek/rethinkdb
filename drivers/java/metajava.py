#!/usr/bin/env python2
from __future__ import print_function
'''
Generates AST terms and serialization code for the Java driver
'''

import re
import os
import os.path
import json
import codecs
import argparse

from collections import OrderedDict, namedtuple
from mako.lookup import TemplateLookup

PACKAGE_DIR = './src/main/java/com/rethinkdb'
TEMPLATE_DIR = './templates'
PROTO_DIR = PACKAGE_DIR + '/proto'
AST_GEN_DIR = PACKAGE_DIR + '/ast/gen'
MODEL_DIR = PACKAGE_DIR + '/model'
PROTO_FILE = '../../src/rdb_protocol/ql2.proto'
PROTO_JSON = './proto_basic.json'
META_JSON = './term_info.json'
GLOBAL_INFO = './global_info.json'
MTIME = os.path.getmtime(__file__)


jsonf = namedtuple("jsonf", "filename json")


def jsonfile(filename):
    return jsonf(filename,
                 json.load(open(filename), object_pairs_hook=OrderedDict))


def parse_args():
    '''Handle command line arguments etc'''
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("command",
                        choices=[
                            'update-terminfo',
                            'render-ast-subclasses',
                        ])
    parser.add_argument("--term-info", type=jsonfile)
    parser.add_argument("--proto-json", type=jsonfile)
    parser.add_argument("--java-term-json", type=jsonfile)
    parser.add_argument("--output-file", "-o")
    return parser.parse_args()


def main():
    args = parse_args()

    if args.command == 'update-term-info':
        update_term_info(args.proto_json, args.term_info)
    elif args.command == 'generate-term-ast':
        render_ast_subclasses(args.term_info.json)
    return #maginot line of conversion
    render_proto_enums(args.proto.json)

    render_ast_subclasses(java_meta)

    global_info = get_global_info()
    render_global_options(global_info['global_optargs'])
    render_exceptions(global_info['exception_hierarchy'])
    render_optarg_enums(global_info['optarg_enums'])


def update_term_info(proto, term_meta):
    '''Updates term_info.json if new terms were discovered in
    proto_basic.json'''
    new_json = diff_proto_keys(proto.json, term_meta.json)
    if new_json != term_meta.json:
        write_term_metadata(term_meta.filename, new_json)
        # term_meta is a tuple, so we re-use the same dict to avoid
        # mutation
        term_meta.json.clear()
        term_meta.json.update(new_json)
    else:
        os.utime(term_meta.filename, None)


def diff_proto_keys(proto, term_meta):
    '''Finds any new keys in the protobuf file and adds dummy entries
    for them in the term_info.json dictionary'''
    set_meta = set(term_meta.keys())
    proto_items = proto['Term']['TermType']
    diff = [x for x in proto_items.keys()
            if x not in set_meta]
    new = term_meta.copy()
    for key in diff:
        print("Got new term", key, "with id", proto_items[key], end='')
        new[key] = OrderedDict([
            ('include_in', ['T_EXPR']),
            ('id', proto_items[key])
        ])
    # Sync up protocol ids (these should never change, but it's best
    # that it's automated since they'd otherwise be specified in two
    # places that would need to be kept in sync.
    for key, val in new.iteritems():
        if val['id'] != proto_items[key]:
            print("Warning: {} changed from {} to {}".format(
                key, val['id'], proto_items[key]))
            val['id'] = proto_items[key]
    return new


def camel(varname):
    'CamelCase'
    return ''.join(x.title() for x in varname.split('_'))


def dromedary(words):
    'dromedaryCase'
    broken = words.split('_')
    return broken[0].lower() + ''.join(x.title() for x in broken[1:])


def reql_to_java_type(reql_type):
    if isinstance(reql_type, list):
        # for enums
        return 'String'
    elif reql_type == 'T_BOOL':
        return 'Boolean'
    elif reql_type == 'T_NUM':
        return 'Double'
    elif reql_type == 'T_STR':
        return 'String'
    else:
        return 'Object'


def java_repr(obj):
    if isinstance(obj, bool):
        return str(obj).lower()
    elif isinstance(obj, basestring):
        return '"{}"'.format(obj)
    elif isinstance(obj, (int, float)):
        return str(obj)
    elif obj is None:
        return 'null'
    else:
        return repr(obj)


def autogenerated_header(template_path, output_path):
    rel_tpl = os.path.relpath(template_path, start=output_path)

    return ('// Autogenerated by {}.\n'
            '// Do not edit this file directly.\n'
            '// The template for this file is located at:\n'
            '// {}\n').format(os.path.basename(__file__), rel_tpl)


def get_term_metadata():
    '''Gets some extra metadata needed to fully generate terms'''
    with codecs.open(META_JSON, "r", 'utf-8') as f:
        return json.load(f, object_pairs_hook=OrderedDict)


def get_global_info():
    '''Gets global metadata from global_info.json'''
    with codecs.open(GLOBAL_INFO, "r", "utf-8") as f:
        return json.load(f)


def write_term_metadata(term_meta):
    with codecs.open(META_JSON, 'w', 'utf-8') as f:
        json.dump(term_meta, f, indent=4)


def java_specific_term_meta(term_meta):
    '''Returns a new term_meta that has java-specific changes. Should
    not be written out to a file, as it's language dependent.'''
    new_meta = term_meta.copy()
    java_keywords = {
        'abstract', 'continue', 'for', 'new', 'switch', 'assert',
        'default', 'goto', 'package', 'synchronized', 'boolean', 'do',
        'if', 'private', 'this', 'break', 'double', 'implements',
        'protected', 'throw', 'byte', 'else', 'import', 'public',
        'throws', 'case', 'enum', 'instanceof', 'return', 'transient',
        'catch', 'extends', 'int', 'short', 'try', 'char', 'final',
        'interface', 'static', 'void', 'class', 'finally', 'long',
        'strictfp', 'volatile', 'const', 'float', 'native', 'super',
        'while'
    }

    java_blacklist = {
        "row"  # Java 8 lambda syntax is nice, so skipping this
    }

    def term_called(info, name, set_):
        return dromedary(name) in set_ or info.get('alias') in set_

    for term_name, info in list(new_meta.items()):
        if term_called(info, term_name, java_blacklist):
            del new_meta[term_name]
        if term_called(info, term_name, java_keywords):
            info = info.copy()
            alias = info.get('alias', dromedary(term_name)) + '_'
            print("Alias for", term_name, "will be", alias)
            info['alias'] = alias
            new_meta[term_name] = info
        if term_name == 'BRACKET':
            new_meta['BRACKET']['alias'] = 'field'
    return new_meta


TL = TemplateLookup(directories=[TEMPLATE_DIR])

template_context = {
    'camel': camel,  # CamelCase function
    'dromedary': dromedary,  # dromeDary case function
}


def dependent_templates(tpl):
    '''Returns filenames for all templates that are inherited from the
    given template'''
    inherit_files = re.findall(r'inherit file="(.*)"', tpl.source)
    op = os.path
    dependencies = set()
    tpl_dir = op.dirname(tpl.filename)
    for parent_relpath in inherit_files:
        parent_filename = op.normpath(op.join(tpl_dir, parent_relpath))
        dependencies.add(parent_filename)
        dependencies.update(
            dependent_templates(
                TL.get_template(
                    TL.filename_to_uri(parent_filename))))
    return dependencies.union([tpl.filename])


def already_rendered(tpl, output_path):
    '''Check if rendered file is already up to date'''
    tpl_mtime = max([os.path.getmtime(t) for t in dependent_templates(tpl)])
    output_exists = os.path.exists(output_path)
    return (output_exists and
            tpl_mtime < os.path.getmtime(output_path) and
            MTIME <= os.path.getmtime(output_path))


def render(template_name, output_dir, output_name=None, **kwargs):
    if output_name is None:
        output_name = template_name

    tpl = TL.get_template(template_name)
    output_path = output_dir + '/' + output_name

    if already_rendered(tpl, output_path):
        return

    with codecs.open(output_path, "w", "utf-8") as outfile:
        print("Rendering", output_path)
        results = template_context.copy()
        results.update(kwargs)
        rendered = tpl.render(**results)
        outfile.write(autogenerated_header(
            TEMPLATE_DIR + '/' + template_name,
            output_path,
        ))
        outfile.write(rendered)


def get_template_name(classname, directory, default):
    '''Returns the template for this class'''
    override_template = '{}/{}.java'.format(directory, classname)
    if TL.has_template(override_template):
        print("    Found an override for {} at {}".format(
            classname, override_template))
        return override_template
    else:
        return default


def render_proto_enums(proto):
    '''Render protocol enums'''
    render_proto_enum("Version", proto["VersionDummy"]["Version"])
    render_proto_enum("Protocol", proto["VersionDummy"]["Protocol"])
    render_proto_enum("QueryType", proto["Query"]["QueryType"])
    render_proto_enum("FrameType", proto["Frame"]["FrameType"])
    render_proto_enum("ResponseType", proto["Response"]["ResponseType"])
    render_proto_enum("ResponseNote", proto["Response"]["ResponseNote"])
    render_proto_enum("ErrorType", proto["Response"]["ErrorType"])
    render_proto_enum("DatumType", proto["Datum"]["DatumType"])
    render_proto_enum("TermType", proto["Term"]["TermType"])


def render_proto_enum(classname, mapping):
    template_name = get_template_name(
        classname, directory='proto', default='Enum.java')
    render(template_name,
           output_dir=PROTO_DIR,
           output_name=classname+'.java',
           classname=classname,
           package='proto',
           items=mapping.items(),
           )


def render_ast_subclass(term_type,
                        include_in,
                        meta,
                        classname=None,
                        superclass="ReqlQuery"):
    '''Generates a ReqlAst subclass. Either term_type or classname should
    be given'''
    classname = classname or camel(term_type)
    output_name = classname + '.java'
    template_name = get_template_name(
        classname, directory='gen', default='AstSubclass.java')
    render(template_name,
           AST_GEN_DIR,
           output_name=output_name,
           term_type=term_type,
           classname=classname,
           meta=meta,
           include_in=include_in,
           superclass=superclass,
           )


def sub_to_super_mapping(type_hierarchy, superclass='ReqlAst'):
    '''Get a data structure for generating the ast hierarchy'''
    mapping = {}
    for ty, subclasses in type_hierarchy:
        if ty in ('T_DATUM', 'T_FUNC'):
            # these won't be generated automatically
            continue
        mapping[ty.lstrip('T_')] = superclass
        mapping.update(sub_to_super_mapping(subclasses, ty.lstrip('T_')))
    return mapping


def render_ast_subclasses(term_info, global_info):
    meta = java_specific_term_meta(term_info.json)
    superclass_of = sub_to_super_mapping(global_info.json['type_hierarchy'])
    for term, metadata in term_info.json:
        pretty_name = camel(term)

    render_ast_subclass(
        term_type=None,
        include_in="T_EXPR",
        meta=meta,
        classname="ReqlQuery",
        superclass=special_superclasses["ReqlQuery"],
    )
    render_ast_subclass(
        term_type=None,
        include_in="T_TOP_LEVEL",
        meta=meta,
        classname="TopLevel",
        superclass=special_superclasses["TopLevel"],
    )
    for term_name, info in list(meta.items()):
        if not info.get('deprecated'):
            render_ast_subclass(
                term_type=term_name,
                include_in=term_name.lower().lstrip('t_'),
                meta=meta,
                superclass=special_superclasses.get(term_name, "ReqlQuery"),
                classname=None,
            )


def render_global_options(global_optargs):
    '''Renders the GlobalOptions class'''
    render(
        "GlobalOptions.java",
        output_dir=MODEL_DIR,
        global_optargs=sorted(global_optargs.items()),
        reql_to_java_type=reql_to_java_type,
        dromedary=dromedary,
        java_repr=java_repr,
    )


def render_exceptions(hierarchy, superclass='runtime_exception'):
    '''Renders the exception hierarchy'''
    for classname, subclasses in hierarchy.items():
        render_exception(classname, superclass)
        render_exceptions(subclasses, superclass=classname)


def render_exception(classname, superclass):
    '''Renders a single exception class'''
    render(
        'Exception.java',
        output_dir=PACKAGE_DIR,
        output_name=camel(classname)+'.java',
        classname=classname,
        superclass=superclass,
        camel=camel,
    )


def get_proto_file(proto_json):
    '''Loads proto file as json'''
    return json.loads(open(proto_json))


def render_optarg_enums(enum_listing):
    for key, values in enum_listing.items():
        classname = camel(key.lstrip('E_'))
        enum_name_mapping = {val: '"'+val+'"' for val in values}
        template_name = get_template_name(
            classname, directory='model', default='Enum.java')
        render(template_name,
               output_dir=MODEL_DIR,
               output_name=classname+'.java',
               classname=classname,
               package="model",
               items=enum_name_mapping.items())




if __name__ == '__main__':
    main()
